

// === File: DraggableElement.jsx ===
import React, { useState, useRef, useEffect, useContext } from 'react';
import { CertificateContext } from '../../../contexts/CertificateContext';

const DraggableElement = ({ id, children, defaultPosition, isDisabled = false }) => {
  const { updateElementPosition } = useContext(CertificateContext);
  const [position, setPosition] = useState(defaultPosition);
  const [isDragging, setIsDragging] = useState(false);
  const [offset, setOffset] = useState({ x: 0, y: 0 });
  const elementRef = useRef(null);
  const containerRef = useRef(document.querySelector('.certificate-template'));

  const handleMouseDown = (e) => {
    if (isDisabled) return;
    
    setIsDragging(true);
    const rect = elementRef.current.getBoundingClientRect();
    setOffset({
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    });
    e.preventDefault();
  };

  const handleMouseMove = (e) => {
    if (!isDragging || isDisabled) return;
    
    if (!containerRef.current) {
      containerRef.current = document.querySelector('.certificate-template');
      if (!containerRef.current) return;
    }

    const containerRect = containerRef.current.getBoundingClientRect();
    const elementRect = elementRef.current.getBoundingClientRect();
    
    // Calculate new position with full container bounds
    let newX = e.clientX - containerRect.left - offset.x;
    let newY = e.clientY - containerRect.top - offset.y;
    
    // Allow dragging to edges by considering element width/height
    newX = Math.max(0, Math.min(newX, containerRect.width - elementRect.width));
    newY = Math.max(0, Math.min(newY, containerRect.height - elementRect.height));
    
    const newPosition = { x: newX, y: newY };
    
    setPosition(newPosition);
    updateElementPosition(id, newPosition);
  };

  const handleMouseUp = () => {
    setIsDragging(false);
  };

  useEffect(() => {
    if (isDragging) {
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
      return () => {
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
      };
    }
  }, [isDragging, offset]);

  const style = {
    position: 'absolute',
    left: `${position.x}px`,
    top: `${position.y}px`,
    cursor: isDragging ? 'grabbing' : (isDisabled ? 'default' : 'grab'),
    zIndex: isDragging ? 1000 : 1
  };

  return (
    <div
      ref={elementRef}
      id={id}
      style={style}
      onMouseDown={handleMouseDown}
      className="draggable-element"
    >
      {children}
    </div>
  );
};

export default DraggableElement;

// === File: PreviewPanel.css ===


// === File: PreviewPanel.jsx ===
import React, { useContext } from 'react';
import { CertificateContext } from '../../contexts/CertificateContext';
import { toPng, toJpeg } from 'html-to-image';
import { saveAs } from 'file-saver';
import Certificate from '../Certificate/Certificate';
import './PreviewPanel.css';

const PreviewPanel = () => {
  const { certificate } = useContext(CertificateContext);
  const certificateRef = React.useRef(null);

  const downloadCertificate = async (format) => {
    if (!certificateRef.current) return;

    try {
      let dataUrl;
      const options = {
        quality: 0.95,
        pixelRatio: 2,
        backgroundColor: '#ffffff'
      };

      switch (format) {
        case 'png':
          dataUrl = await toPng(certificateRef.current, options);
          saveAs(dataUrl, `${certificate.recipientName || 'certificate'}.png`);
          break;
        case 'jpeg':
          dataUrl = await toJpeg(certificateRef.current, options);
          saveAs(dataUrl, `${certificate.recipientName || 'certificate'}.jpg`);
          break;
        case 'pdf':
          alert('PDF export would be implemented with jsPDF');
          break;
        default:
          break;
      }
    } catch (error) {
      console.error('Error generating image:', error);
    }
  };

  return (
    <div className="preview-panel">
      <h3>Preview & Export</h3>
      
      <div className="preview-container">
        <div className="certificate-preview" ref={certificateRef}>
          <Certificate isPreview={true} />
        </div>
      </div>

      <div className="export-options">
        <h4>Export Options</h4>
        <div className="export-buttons">
          <button onClick={() => downloadCertificate('png')}>PNG</button>
          <button onClick={() => downloadCertificate('jpeg')}>JPEG</button>
          <button onClick={() => downloadCertificate('pdf')}>PDF</button>
        </div>
      </div>

      <div className="certificate-info">
        <h4>Certificate Details</h4>
        <ul>
          <li><strong>Recipient:</strong> {certificate.recipientName || "Not specified"}</li>
          <li><strong>Course:</strong> {certificate.courseName || "Not specified"}</li>
          <li><strong>Date:</strong> {certificate.date}</li>
          <li><strong>Signatures:</strong> {certificate.signatures.length}</li>
          <li><strong>Logos:</strong> {certificate.logos.length}</li>
        </ul>
      </div>
    </div>
  );
};

export default PreviewPanel;

// === File: Toolbar.css ===


// === File: Toolbar.jsx ===
import React, { useState, useContext } from 'react'; // Added useContext import here
import { CertificateContext } from '../../../contexts/CertificateContext';
import { FaFileAlt, FaDownload, FaUndo, FaRedo, FaSave, FaShareAlt } from 'react-icons/fa';
import PreviewModal from '../Certificate/PreviewModal';
import './Toolbar.css';

const Toolbar = () => {
  const { certificate, updateCertificate } = useContext(CertificateContext);
  const [showPreview, setShowPreview] = useState(false);

  const handleNewCertificate = () => {
    if (window.confirm('Are you sure you want to create a new certificate? All current changes will be lost.')) {
      updateCertificate({
        title: "Certificate of Completion",
        recipientName: "",
        courseName: "",
        date: new Date().toLocaleDateString(),
        signatures: [],
        logos: [],
        template: "classic",
        barcodeData: "https://cmvp.net/verification/4b832a6e-bba1-4e15-b7d5-6da5657512f0/ARTS/"
      });
    }
  };

  const handleSave = () => {
    // First save to local storage
    localStorage.setItem('certificateData', JSON.stringify(certificate));
    // Then show preview
    setShowPreview(true);
  };

  const handleLoad = () => {
    const savedData = localStorage.getItem('certificateData');
    if (savedData) {
      if (window.confirm('Load saved certificate? Current changes will be lost.')) {
        updateCertificate(JSON.parse(savedData));
      }
    } else {
      alert('No saved certificate found');
    }
  };

  return (
    <>
      <div className="toolbar">
        <div className="toolbar-left">
          <h1 className="app-title">Certificate Builder</h1>
        </div>
        
        <div className="toolbar-center">
          <button className="toolbar-button" onClick={handleNewCertificate}>
            <FaFileAlt className="toolbar-icon" />
            <span>New</span>
          </button>
          
          <button className="toolbar-button" onClick={handleSave}>
            <FaSave className="toolbar-icon" />
            <span>Preview & Save </span>
          </button>
          
          <button className="toolbar-button" onClick={handleLoad}>
            <FaFileAlt className="toolbar-icon" />
            <span>Load</span>
          </button>
        </div>
      </div>

      {showPreview && (
        <PreviewModal onClose={() => setShowPreview(false)} />
      )}
    </>
  );
};

export default Toolbar;

import React, { createContext, useState, useCallback } from 'react';

export const CertificateContext = createContext();

export const CertificateProvider = ({ children }) => {
  const [history, setHistory] = useState([{
    title: "Certificate of Completion",
    recipientName: "",
    courseName: "",
    date: new Date().toLocaleDateString(),
    signatures: [],
    logos: [],
    template: "classic",
    templateImage: null,
    barcodeData: "https://cmvp.net/verification/4b832a6e-bba1-4e15-b7d5-6da5657512f0/ARTS/",
    backgroundColor: 'transparent',
    borderColor: '#f1c40f',
    borderWidth: '15px',
    borderStyle: 'solid',
    completionText: 'has successfully completed the course',
  }]);
  
  const [historyIndex, setHistoryIndex] = useState(0);
  const certificate = history[historyIndex];

  const updateCertificate = useCallback((updates, recordHistory = false) => {
    if (recordHistory) {
      const newHistory = history.slice(0, historyIndex + 1);
      newHistory.push({ ...certificate, ...updates });
      setHistory(newHistory);
      setHistoryIndex(newHistory.length - 1);
    } else {
      setHistory(prev => {
        const newHistory = [...prev];
        newHistory[historyIndex] = { ...certificate, ...updates };
        return newHistory;
      });
    }
  }, [certificate, history, historyIndex]);

  const undo = useCallback(() => {
    if (historyIndex > 0) {
      setHistoryIndex(prev => prev - 1);
    }
  }, [historyIndex]);

  const redo = useCallback(() => {
    if (historyIndex < history.length - 1) {
      setHistoryIndex(prev => prev + 1);
    }
  }, [history, historyIndex]);

  const addSignature = useCallback((signature) => {
    updateCertificate({
      signatures: [...certificate.signatures, signature]
    }, true);
  }, [certificate.signatures, updateCertificate]);

  const updateSignature = useCallback((index, updates) => {
    const updatedSignatures = [...certificate.signatures];
    updatedSignatures[index] = { ...updatedSignatures[index], ...updates };
    updateCertificate({ signatures: updatedSignatures }, true);
  }, [certificate.signatures, updateCertificate]);

  const removeSignature = useCallback((index) => {
    updateCertificate({
      signatures: certificate.signatures.filter((_, i) => i !== index)
    }, true);
  }, [certificate.signatures, updateCertificate]);

  const addLogo = useCallback((logo) => {
    updateCertificate({
      logos: [...certificate.logos, logo]
    }, true);
  }, [certificate.logos, updateCertificate]);

  const updateLogo = useCallback((index, updates) => {
    const updatedLogos = [...certificate.logos];
    updatedLogos[index] = { ...updatedLogos[index], ...updates };
    updateCertificate({ logos: updatedLogos }, true);
  }, [certificate.logos, updateCertificate]);

  const removeLogo = useCallback((index) => {
    updateCertificate({
      logos: certificate.logos.filter((_, i) => i !== index)
    }, true);
  }, [certificate.logos, updateCertificate]);

  const updateCompletionTextPosition = useCallback((position) => {
    updateCertificate({
      completionTextPosition: position
    });
  }, [updateCertificate]);

  return (
    <CertificateContext.Provider value={{
      certificate,
      updateCertificate,
      history,
      historyIndex,
      undo,
      redo,
      addSignature,
      updateSignature,
      removeSignature,
      addLogo,
      updateLogo,
      removeLogo,
      updateCompletionTextPosition
    }}>
      {children}
    </CertificateContext.Provider>
  );
};

// === File: BarcodeGenerator.jsx ===
// BarcodeGenerator.jsx
import React, { useEffect, useRef } from 'react';
import QRCode from 'qrcode';

const BarcodeGenerator = ({ data }) => {
  const canvasRef = useRef(null);

  useEffect(() => {
    if (data && canvasRef.current) {
      QRCode.toCanvas(canvasRef.current, data, { width: 120 }, (error) => {
        if (error) console.error('Error generating QR code:', error);
      });
    }
  }, [data]);

  return <canvas ref={canvasRef} />;
};

export default BarcodeGenerator;

// === File: BulkCertificateControls.css ===


// === File: BulkCertificateControls.jsx ===
import React, { useState, useContext, useEffect } from 'react';
import { CertificateContext } from '../../../contexts/CertificateContext';
import * as XLSX from 'xlsx';
import PreviewModal from '../Certificate/PreviewModal';
import './BulkCertificateControls.css';

const dummyRecipients = [
  { id: 1, fullName: "John Doe", email: "john@example.com", course: "Advanced React" },
  { id: 2, fullName: "Jane Smith", email: "jane@example.com", course: "Node.js Fundamentals" },
  { id: 3, fullName: "Alex Johnson", email: "alex@example.com", course: "UI/UX Design" },
  { id: 4, fullName: "Alex Ekwueme", email: "john@example.com", course: "Advanced React" },
  { id: 5, fullName: "Sarah Williams", email: "sarah@example.com", course: "Data Science" },
  { id: 6, fullName: "Michael Brown", email: "michael@example.com", course: "DevOps Engineering" },
  { id: 7, fullName: "Emily Davis", email: "emily@example.com", course: "Cloud Computing" },
];

const BulkCertificateControls = () => {
  const { certificate, updateCertificate } = useContext(CertificateContext);
  const [recipients, setRecipients] = useState([]);
  const [selectedRecipients, setSelectedRecipients] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [templateData, setTemplateData] = useState({});
  const [dataSource, setDataSource] = useState('api');
  const [columns, setColumns] = useState([]);
  const [nameColumn, setNameColumn] = useState('fullName');
  const [courseColumn, setCourseColumn] = useState('course');
  const [generatedCertificates, setGeneratedCertificates] = useState([]);
  const [showPreview, setShowPreview] = useState(false);
  const [currentPreviewIndex, setCurrentPreviewIndex] = useState(0);

  useEffect(() => {
    if (dataSource === 'api') {
      const fetchRecipients = async () => {
        setIsLoading(true);
        try {
          await new Promise(resolve => setTimeout(resolve, 1000));
          setRecipients(dummyRecipients);
          setColumns(['id', 'fullName', 'email', 'course']);
        } catch (error) {
          console.error("Error fetching recipients:", error);
        } finally {
          setIsLoading(false);
        }
      };
      fetchRecipients();
    }
  }, [dataSource]);

  const handleFileUpload = (e) => {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    
    reader.onload = (e) => {
      setIsLoading(true);
      try {
        const data = new Uint8Array(e.target.result);
        const workbook = XLSX.read(data, { type: 'array' });
        const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
        const jsonData = XLSX.utils.sheet_to_json(firstSheet);
        
        if (jsonData.length > 0) {
          setRecipients(jsonData);
          setColumns(Object.keys(jsonData[0]));
          const firstRow = jsonData[0];
          const autoNameCol = Object.keys(firstRow).find(k => 
            k.match(/name|fullname|student/i)
          );
          const autoCourseCol = Object.keys(firstRow).find(k => 
            k.match(/course|subject|class/i)
          );
          if (autoNameCol) setNameColumn(autoNameCol);
          if (autoCourseCol) setCourseColumn(autoCourseCol);
        }
      } catch (error) {
        console.error("Error processing Excel file:", error);
        alert("Error processing Excel file. Please check the format.");
      } finally {
        setIsLoading(false);
      }
    };
    
    reader.readAsArrayBuffer(file);
  };

  const toggleRecipientSelection = (id) => {
    setSelectedRecipients(prev => 
      prev.includes(id) 
        ? prev.filter(item => item !== id) 
        : [...prev, id]
    );
  };

  const saveTemplateData = () => {
    const { recipientName, ...currentTemplate } = certificate;
    setTemplateData(currentTemplate);
    alert('Template settings saved! These will be applied to all generated certificates.');
  };

  const previewCertificate = (recipientId) => {
    const recipient = recipients.find(r => 
      dataSource === 'api' ? r.id === recipientId : r === recipientId
    );
    if (recipient) {
      updateCertificate({
        ...templateData,
        recipientName: recipient[nameColumn],
        courseName: recipient[courseColumn] || ''
      });
    }
  };

  const generateAllCertificates = async () => {
    if (selectedRecipients.length === 0) return;
    
    setIsLoading(true);
    try {
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      const certs = selectedRecipients.map(id => {
        const recipient = recipients.find(r => 
          dataSource === 'api' ? r.id === id : r === id
        );
        return {
          ...templateData,
          recipientName: recipient[nameColumn],
          courseName: recipient[courseColumn] || ''
        };
      });

      setGeneratedCertificates(certs);
      alert(`Successfully processed ${certs.length} certificates!`);
      
      if (certs.length > 0) {
        updateCertificate(certs[0]);
        setCurrentPreviewIndex(0);
        setShowPreview(true);
      }
    } catch (error) {
      console.error("Error generating certificates:", error);
      alert("Failed to generate certificates. Please try again.");
    } finally {
      setIsLoading(false);
    }
  };

  const navigatePreview = (direction) => {
    let newIndex = currentPreviewIndex;
    if (direction === 'prev' && currentPreviewIndex > 0) {
      newIndex = currentPreviewIndex - 1;
    } else if (direction === 'next' && currentPreviewIndex < generatedCertificates.length - 1) {
      newIndex = currentPreviewIndex + 1;
    }
    
    if (newIndex !== currentPreviewIndex) {
      setCurrentPreviewIndex(newIndex);
      updateCertificate(generatedCertificates[newIndex]);
    }
  };

  const downloadAllCertificates = async (format) => {
    if (generatedCertificates.length === 0) return;
    
    setIsLoading(true);
    try {
      for (let i = 0; i < generatedCertificates.length; i++) {
        const cert = generatedCertificates[i];
        updateCertificate(cert);
        await new Promise(resolve => setTimeout(resolve, 100));
        console.log(`Would download certificate for ${cert.recipientName} as ${format}`);
      }
      alert(`Download process completed for ${generatedCertificates.length} certificates!`);
    } catch (error) {
      console.error("Error downloading certificates:", error);
      alert("Failed to download certificates. Please try again.");
    } finally {
      setIsLoading(false);
    }
  };

  const selectAllRecipients = () => {
    if (selectedRecipients.length === recipients.length) {
      setSelectedRecipients([]);
    } else {
      setSelectedRecipients(
        dataSource === 'api' 
          ? recipients.map(r => r.id) 
          : [...recipients]
      );
    }
  };

  return (
    <div className="bulk-certificate-controls">
      <h3>Bulk Certificate Generator</h3>
      
      <div className="data-source-selector">
        <label>
          <input
            type="radio"
            checked={dataSource === 'api'}
            onChange={() => setDataSource('api')}
          />
          Use Sample API Data
        </label>
        <label>
          <input
            type="radio"
            checked={dataSource === 'excel'}
            onChange={() => setDataSource('excel')}
          />
          Upload Excel File
        </label>
      </div>
      
      {dataSource === 'excel' && (
        <div className="form-group">
          <label>Upload Excel File</label>
          <input 
            type="file" 
            accept=".xlsx, .xls, .csv" 
            onChange={handleFileUpload} 
            disabled={isLoading}
          />
        </div>
      )}
      
      {columns.length > 0 && dataSource === 'excel' && (
        <div className="column-mapping">
          <div className="form-group">
            <label>Name Column</label>
            <select 
              value={nameColumn} 
              onChange={(e) => setNameColumn(e.target.value)}
              disabled={isLoading}
            >
              {columns.map((col, i) => (
                <option key={i} value={col}>{col}</option>
              ))}
            </select>
          </div>
          <div className="form-group">
            <label>Course Column (optional)</label>
            <select 
              value={courseColumn} 
              onChange={(e) => setCourseColumn(e.target.value)}
              disabled={isLoading}
            >
              <option value="">None</option>
              {columns.map((col, i) => (
                <option key={i} value={col}>{col}</option>
              ))}
            </select>
          </div>
        </div>
      )}
      
      <div className="api-status">
        {isLoading ? (
          <div className="loading-indicator">Loading data...</div>
        ) : (
          <div className="success-message">
            {recipients.length} {dataSource === 'api' ? 'sample' : 'uploaded'} recipients available
          </div>
        )}
      </div>
      
      {recipients.length > 0 && (
        <>
          <div className="recipients-header">
            <h4>Select Recipients ({selectedRecipients.length} selected)</h4>
            <button 
              onClick={selectAllRecipients}
              className="select-all-btn"
            >
              {selectedRecipients.length === recipients.length ? 'Deselect All' : 'Select All'}
            </button>
          </div>
          <div className="recipients-scroll">
            {recipients.map((recipient, index) => {
              const id = dataSource === 'api' ? recipient.id : index;
              return (
                <div 
                  key={dataSource === 'api' ? recipient.id : index}
                  className={`recipient-item ${selectedRecipients.includes(id) ? 'selected' : ''}`}
                  onClick={() => toggleRecipientSelection(id)}
                >
                  <div className="recipient-name">{recipient[nameColumn]}</div>
                  {courseColumn && recipient[courseColumn] && (
                    <div className="recipient-course">{recipient[courseColumn]}</div>
                  )}
                </div>
              );
            })}
          </div>
        </>
      )}
      
      <div className="bulk-actions">
        <button 
          onClick={saveTemplateData} 
          className="secondary"
          disabled={isLoading}
        >
          Save Template Settings
        </button>
        
        <button 
          onClick={() => previewCertificate(selectedRecipients[0])} 
          disabled={selectedRecipients.length === 0 || isLoading}
        >
          Preview Selected Certificate
        </button>
        
        <button 
          onClick={generateAllCertificates} 
          disabled={selectedRecipients.length === 0 || isLoading}
          className="primary"
        >
          {isLoading ? 'Generating...' : `Generate All (${selectedRecipients.length})`}
        </button>
        
        {generatedCertificates.length > 0 && (
          <>
            <button 
              onClick={() => {
                setCurrentPreviewIndex(0);
                updateCertificate(generatedCertificates[0]);
                setShowPreview(true);
              }}
              className="secondary"
            >
              Preview All Certificates
            </button>
            <button 
              onClick={() => downloadAllCertificates('pdf')}
              className="primary"
              disabled={isLoading}
            >
              {isLoading ? 'Processing...' : `Download All (${generatedCertificates.length})`}
            </button>
          </>
        )}
      </div>

      {showPreview && generatedCertificates.length > 0 && (
        <PreviewModal 
          onClose={() => setShowPreview(false)}
          onNavigate={navigatePreview}
          currentIndex={currentPreviewIndex}
          totalCertificates={generatedCertificates.length}
          onDownloadAll={() => downloadAllCertificates('pdf')}
        />
      )}
    </div>
  );
};

export default BulkCertificateControls;

// === File: Certificate.css ===


// === File: Certificate.jsx ===
// === File: Certificate.jsx ===
import React, { useContext } from 'react';
import { CertificateContext } from '../../../contexts/CertificateContext';
import { Box, Paper, Typography } from '@mui/material';
import BarcodeGenerator from './BarcodeGenerator';
import DraggableElement from '../UI/DraggableElement';

// Import template images
import classicTemplate from '../../../assets/templates/classic.jpg';
import modernTemplate from '../../../assets/templates/modern.jpg';
import elegantTemplate from '../../../assets/templates/elegant.png';
import minimalTemplate from '../../../assets/templates/minimal.jpg';

const Certificate = () => {
  const { certificate } = useContext(CertificateContext);
  const { 
    title, 
    recipientName, 
    courseName, 
    completionText,
    date, 
    signatures, 
    logos, 
    barcodeData,
    template = 'classic', 
    templateImage,
    borderColor = '#f1c40f',
    borderWidth = '15px',
    borderStyle = 'solid'
  } = certificate;

  // Map template IDs to their image files
  const templateImages = {
    classic: classicTemplate,
    modern: modernTemplate,
    elegant: elegantTemplate,
    minimal: minimalTemplate
  };

  // Use custom template if available, otherwise use predefined
  const backgroundImage = templateImage || templateImages[template];

  return (
    <Paper 
      elevation={3}
      sx={{
        width: '100%',
        maxWidth: '1000px',
        aspectRatio: '4/3',
        position: 'relative',
        backgroundImage: `url(${backgroundImage})`,
        backgroundSize: 'cover',
        backgroundPosition: 'center',
        backgroundRepeat: 'no-repeat',
        borderColor,
        borderWidth,
        borderStyle,
        p: 4,
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        overflow: 'hidden',
        mx: 'auto',
        my: 2
      }}
    >
      <Typography 
        variant="h3" 
        component="h1" 
        sx={{ 
          fontWeight: 700,
          color: 'text.primary',
          mb: 2,
          textAlign: 'center'
        }}
      >
        {title}
      </Typography>
      
      <Typography variant="body1" sx={{ mb: 2, textAlign: 'center' }}>
        This is to certify that
      </Typography>
      
      <Typography 
        variant="h2" 
        component="h2" 
        sx={{ 
          fontWeight: 600,
          color: 'primary.main',
          mb: 2,
          textAlign: 'center'
        }}
      >
        {recipientName || "[Recipient Name]"}
      </Typography>
      
      <Typography variant="body1" sx={{ mb: 2, textAlign: 'center' }}>
        {completionText || "has successfully completed the course"}
      </Typography>
      
      <Typography 
        variant="h4" 
        component="h3" 
        sx={{ 
          fontWeight: 500,
          color: 'text.secondary',
          mb: 2,
          textAlign: 'center'
        }}
      >
        {courseName || "[Course Name]"}
      </Typography>
      
      <Typography variant="body1" sx={{ mb: 4, textAlign: 'center' }}>
        on this {date}
      </Typography>
      
      <Box 
        sx={{ 
          display: 'flex',
          justifyContent: 'space-around',
          width: '100%',
          mt: 'auto',
          position: 'relative',
          height: '120px'
        }}
      >
        {signatures.map((sig, index) => (
          <DraggableElement 
            key={index} 
            id={`signature-${index}`} 
            defaultPosition={sig.position}
            bounds="parent"
          >
            <Box sx={{ 
              display: 'flex',
              flexDirection: 'column',
              alignItems: 'center'
            }}>
              <Box 
                component="img"
                src={sig.image} 
                alt="Signature" 
                sx={{ 
                  width: '120px', 
                  height: 'auto',
                  mb: 1
                }}
              />
              <Typography variant="body2">{sig.name || "[Name]"}</Typography>
              <Typography variant="caption">{sig.date || "[Date]"}</Typography>
            </Box>
          </DraggableElement>
        ))}
      </Box>

      {/* Logos */}
      {logos.map((logo, index) => (
        <DraggableElement 
          key={`logo-${index}`} 
          id={`logo-${index}`} 
          defaultPosition={logo?.position || { x: 50, y: 50 }}
          bounds="parent"
        >
          <Box 
            component="img"
            src={logo?.image} 
            alt={`Logo ${index + 1}`}
            sx={{
              width: '100px',
              height: 'auto',
            }}
          />
        </DraggableElement>
      ))}

      {/* Barcode */}
      <Box sx={{ 
        position: 'absolute',
        bottom: 16,
        right: 16
      }}>
        <BarcodeGenerator data={barcodeData} />
      </Box>
    </Paper>
  );
};

export default Certificate;

// === File: CertificateControls.css ===


// === File: CertificateControls.jsx ===
// === File: BulkCertificateControls.jsx ===
import React, { useState, useContext } from 'react';
import { CertificateContext } from '../../../contexts/CertificateContext';
import * as XLSX from 'xlsx';
import { 
  Box, 
  Typography, 
  Button, 
  Radio, 
  RadioGroup, 
  FormControlLabel, 
  FormControl, 
  InputLabel, 
  Select, 
  MenuItem,
  CircularProgress,
  Paper,
  Checkbox,
  Divider
} from '@mui/material';
import PreviewModal from '../Certificate/PreviewModal';

const dummyRecipients = [
  { id: 1, fullName: "John Doe", email: "john@example.com", course: "Advanced React" },
  { id: 2, fullName: "Jane Smith", email: "jane@example.com", course: "Node.js Fundamentals" },
  { id: 3, fullName: "Alex Johnson", email: "alex@example.com", course: "UI/UX Design" },
];

const BulkCertificateControls = () => {
  const { certificate, updateCertificate } = useContext(CertificateContext);
  const [recipients, setRecipients] = useState([]);
  const [selectedRecipients, setSelectedRecipients] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [templateData, setTemplateData] = useState({});
  const [dataSource, setDataSource] = useState('api');
  const [columns, setColumns] = useState([]);
  const [nameColumn, setNameColumn] = useState('fullName');
  const [courseColumn, setCourseColumn] = useState('course');
  const [generatedCertificates, setGeneratedCertificates] = useState([]);
  const [showPreview, setShowPreview] = useState(false);
  const [currentPreviewIndex, setCurrentPreviewIndex] = useState(0);

  const handleFileUpload = (e) => {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
      setIsLoading(true);
      try {
        const data = new Uint8Array(e.target.result);
        const workbook = XLSX.read(data, { type: 'array' });
        const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
        const jsonData = XLSX.utils.sheet_to_json(firstSheet);
        
        if (jsonData.length > 0) {
          setRecipients(jsonData);
          setColumns(Object.keys(jsonData[0]));
          const firstRow = jsonData[0];
          const autoNameCol = Object.keys(firstRow).find(k => 
            k.match(/name|fullname|student/i)
          );
          const autoCourseCol = Object.keys(firstRow).find(k => 
            k.match(/course|subject|class/i)
          );
          if (autoNameCol) setNameColumn(autoNameCol);
          if (autoCourseCol) setCourseColumn(autoCourseCol);
        }
      } catch (error) {
        console.error("Error processing Excel file:", error);
      } finally {
        setIsLoading(false);
      }
    };
    reader.readAsArrayBuffer(file);
  };

  const toggleRecipientSelection = (id) => {
    setSelectedRecipients(prev => 
      prev.includes(id) 
        ? prev.filter(item => item !== id) 
        : [...prev, id]
    );
  };

  const saveTemplateData = () => {
    const { recipientName, ...currentTemplate } = certificate;
    setTemplateData(currentTemplate);
  };

  const generateAllCertificates = async () => {
    if (selectedRecipients.length === 0) return;
    
    setIsLoading(true);
    try {
      const certs = selectedRecipients.map(id => {
        const recipient = recipients.find(r => 
          dataSource === 'api' ? r.id === id : r === id
        );
        return {
          ...templateData,
          recipientName: recipient[nameColumn],
          courseName: recipient[courseColumn] || ''
        };
      });

      setGeneratedCertificates(certs);
      
      if (certs.length > 0) {
        updateCertificate(certs[0]);
        setCurrentPreviewIndex(0);
        setShowPreview(true);
      }
    } catch (error) {
      console.error("Error generating certificates:", error);
    } finally {
      setIsLoading(false);
    }
  };

  const navigatePreview = (direction) => {
    let newIndex = currentPreviewIndex;
    if (direction === 'prev' && currentPreviewIndex > 0) {
      newIndex = currentPreviewIndex - 1;
    } else if (direction === 'next' && currentPreviewIndex < generatedCertificates.length - 1) {
      newIndex = currentPreviewIndex + 1;
    }
    
    if (newIndex !== currentPreviewIndex) {
      setCurrentPreviewIndex(newIndex);
      updateCertificate(generatedCertificates[newIndex]);
    }
  };

  const selectAllRecipients = () => {
    if (selectedRecipients.length === recipients.length) {
      setSelectedRecipients([]);
    } else {
      setSelectedRecipients(
        dataSource === 'api' 
          ? recipients.map(r => r.id) 
          : [...recipients]
      );
    }
  };

  return (
    <Box sx={{ p: 2 }}>
      <Typography variant="h6" sx={{ mb: 2 }}>Bulk Certificate Generator</Typography>
      
      <FormControl component="fieldset" sx={{ mb: 3 }}>
        <RadioGroup 
          row 
          value={dataSource} 
          onChange={(e) => setDataSource(e.target.value)}
        >
          <FormControlLabel 
            value="api" 
            control={<Radio />} 
            label="Use Sample API Data" 
          />
          <FormControlLabel 
            value="excel" 
            control={<Radio />} 
            label="Upload Excel File" 
          />
        </RadioGroup>
      </FormControl>
      
      {dataSource === 'excel' && (
        <Box sx={{ mb: 3 }}>
          <Button 
            variant="contained"
            component="label"
            disabled={isLoading}
          >
            Upload Excel File
            <input 
              type="file" 
              hidden 
              accept=".xlsx, .xls, .csv" 
              onChange={handleFileUpload} 
            />
          </Button>
        </Box>
      )}
      
      {columns.length > 0 && dataSource === 'excel' && (
        <Box sx={{ display: 'flex', gap: 2, mb: 3 }}>
          <FormControl fullWidth size="small">
            <InputLabel>Name Column</InputLabel>
            <Select 
              value={nameColumn} 
              onChange={(e) => setNameColumn(e.target.value)}
              disabled={isLoading}
            >
              {columns.map((col, i) => (
                <MenuItem key={i} value={col}>{col}</MenuItem>
              ))}
            </Select>
          </FormControl>
          
          <FormControl fullWidth size="small">
            <InputLabel>Course Column</InputLabel>
            <Select 
              value={courseColumn} 
              onChange={(e) => setCourseColumn(e.target.value)}
              disabled={isLoading}
            >
              <MenuItem value="">None</MenuItem>
              {columns.map((col, i) => (
                <MenuItem key={i} value={col}>{col}</MenuItem>
              ))}
            </Select>
          </FormControl>
        </Box>
      )}
      
      {isLoading ? (
        <Box sx={{ display: 'flex', justifyContent: 'center', my: 3 }}>
          <CircularProgress />
        </Box>
      ) : (
        <Typography variant="body2" sx={{ mb: 2 }}>
          {recipients.length} {dataSource === 'api' ? 'sample' : 'uploaded'} recipients available
        </Typography>
      )}
      
      {recipients.length > 0 && (
        <>
          <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 2 }}>
            <Typography variant="subtitle1">
              Select Recipients ({selectedRecipients.length} selected)
            </Typography>
            <Button 
              onClick={selectAllRecipients}
              size="small"
            >
              {selectedRecipients.length === recipients.length ? 'Deselect All' : 'Select All'}
            </Button>
          </Box>
          
          <Paper sx={{ maxHeight: 300, overflow: 'auto', mb: 3 }}>
            {recipients.map((recipient, index) => {
              const id = dataSource === 'api' ? recipient.id : index;
              return (
                <Box 
                  key={dataSource === 'api' ? recipient.id : index}
                  sx={{
                    p: 1,
                    display: 'flex',
                    alignItems: 'center',
                    borderBottom: '1px solid',
                    borderColor: 'divider',
                    bgcolor: selectedRecipients.includes(id) ? 'action.selected' : 'background.paper',
                    '&:hover': {
                      bgcolor: 'action.hover',
                      cursor: 'pointer'
                    }
                  }}
                  onClick={() => toggleRecipientSelection(id)}
                >
                  <Checkbox 
                    checked={selectedRecipients.includes(id)}
                    onChange={() => toggleRecipientSelection(id)}
                    onClick={(e) => e.stopPropagation()}
                  />
                  <Box sx={{ ml: 1 }}>
                    <Typography>{recipient[nameColumn]}</Typography>
                    {courseColumn && recipient[courseColumn] && (
                      <Typography variant="body2" color="text.secondary">
                        {recipient[courseColumn]}
                      </Typography>
                    )}
                  </Box>
                </Box>
              );
            })}
          </Paper>
        </>
      )}
      
      <Divider sx={{ my: 2 }} />
      
      <Box sx={{ display: 'flex', gap: 2, flexWrap: 'wrap' }}>
        <Button 
          variant="outlined"
          onClick={saveTemplateData} 
          disabled={isLoading}
        >
          Save Template Settings
        </Button>
        
        <Button 
          variant="outlined"
          onClick={() => previewCertificate(selectedRecipients[0])} 
          disabled={selectedRecipients.length === 0 || isLoading}
        >
          Preview Selected Certificate
        </Button>
        
        <Button 
          variant="contained"
          onClick={generateAllCertificates} 
          disabled={selectedRecipients.length === 0 || isLoading}
        >
          {isLoading ? 'Generating...' : `Generate All (${selectedRecipients.length})`}
        </Button>
        
        {generatedCertificates.length > 0 && (
          <>
            <Button 
              variant="outlined"
              onClick={() => {
                setCurrentPreviewIndex(0);
                updateCertificate(generatedCertificates[0]);
                setShowPreview(true);
              }}
            >
              Preview All Certificates
            </Button>
            <Button 
              variant="contained"
              onClick={() => downloadAllCertificates('pdf')}
              disabled={isLoading}
            >
              {isLoading ? 'Processing...' : `Download All (${generatedCertificates.length})`}
            </Button>
          </>
        )}
      </Box>

      {showPreview && generatedCertificates.length > 0 && (
        <PreviewModal 
          onClose={() => setShowPreview(false)}
          onNavigate={navigatePreview}
          currentIndex={currentPreviewIndex}
          totalCertificates={generatedCertificates.length}
          onDownloadAll={() => downloadAllCertificates('pdf')}
        />
      )}
    </Box>
  );
};

export default BulkCertificateControls;

// === File: CertificateTemplates.css ===


// === File: CertificateTemplates.jsx ===
import React, { useContext, useState } from 'react';
import { CertificateContext } from '../../../contexts/CertificateContext';
import './CertificateTemplates.css';

// Static imports
import classicImg from '../../../assets/templates/classic.jpg'; 
import modernImg from '../../../assets/templates/modern.jpg';
import elegantImg from '../../../assets/templates/elegant.png';
import minimalImg from '../../../assets/templates/minimal.jpg';

const CertificateTemplates = () => {
  const { certificate, updateCertificate } = useContext(CertificateContext);
  const [customTemplates, setCustomTemplates] = useState([]);

  const templates = [
    {
      id: 'classic',
      name: 'Classic',
      thumbnail: classicImg,
      image: classicImg
    },
    {
      id: 'modern',
      name: 'Modern', 
      thumbnail: modernImg,
      image: modernImg
    },
    {
      id: 'elegant',
      name: 'Elegant',
      thumbnail: elegantImg,
      image: elegantImg
    },
    {
      id: 'minimal',
      name: 'Minimal',
      thumbnail: minimalImg,
      image: minimalImg
    },
    ...customTemplates
  ];

  const handleTemplateSelect = (template) => {
    updateCertificate({
      template: template.id,
      templateImage: template.image
    });
  };

  const handleFileUpload = (e) => {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
      const newTemplate = {
        id: `custom-${Date.now()}`,
        name: file.name.replace(/\.[^/.]+$/, ""), // Remove file extension
        thumbnail: e.target.result,
        image: e.target.result
      };
      setCustomTemplates(prev => [...prev, newTemplate]);
    };
    reader.readAsDataURL(file);
  };

  return (
    <div className="templates-container">
      <h3 className="templates-title">Select Template</h3>
      
      <div className="template-upload">
        <label className="upload-button">
          Upload Custom Template
          <input 
            type="file" 
            accept="image/*" 
            onChange={handleFileUpload}
            style={{ display: 'none' }}
          />
        </label>
      </div>
      
      <div className="templates-scrollable">
        <div className="templates-grid">
          {templates.map(template => (
            <div
              key={template.id}
              className={`template-card ${certificate.template === template.id ? 'active' : ''}`}
              onClick={() => handleTemplateSelect(template)}
            >
              <img
                src={template.thumbnail}
                alt={template.name}
                className="template-image"
                onError={(e) => {
                  e.target.src = 'https://via.placeholder.com/120x80?text=Template';
                }}
              />
              <span className="template-label">{template.name}</span>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
};

export default CertificateTemplates;

// === File: CompletionTextControl.jsx ===
import React, { useContext } from 'react';
import { CertificateContext } from '../contexts/CertificateContext';

const CompletionTextControl = () => {
  const { certificate, updateCertificateField } = useContext(CertificateContext);

  return (
    <div className="form-group">
      <label>Completion Text</label>
      <input
        type="text"
        value={certificate.completionText}
        onChange={(e) => updateCertificateField('completionText', e.target.value)}
        placeholder="e.g., 'has successfully completed the course'"
        className="form-control"
      />
      <small className="form-text text-muted">
        This text appears between the recipient name and course name
      </small>
    </div>
  );
};

export default CompletionTextControl;

// === File: DownloadOptionsModal.css ===


// === File: DownloadOptionsModal.jsx ===
import React from 'react';
import { FiDownload, FiX, FiImage, FiFileText } from 'react-icons/fi';
import { FaFilePdf } from 'react-icons/fa';
import './DownloadOptionsModal.css';

const DownloadOptionsModal = ({ onClose, onDownload }) => {
  return (
    <div className="download-modal-overlay">
      <div className="download-modal">
        <button className="close-button" onClick={onClose}>
          <FiX />
        </button>
        
        <h3>Download Options</h3>
        
        <div className="download-options">
          <button 
            className="download-option"
            onClick={() => onDownload('png')}
          >
            <FiImage className="option-icon" />
            <span>PNG Image</span>
          </button>
          
          <button 
            className="download-option"
            onClick={() => onDownload('jpeg')}
          >
            <FiImage className="option-icon" />
            <span>JPEG Image</span>
          </button>
          
          <button 
            className="download-option"
            onClick={() => onDownload('pdf')}
          >
            <FaFilePdf className="option-icon" />
            <span>PDF Document</span>
          </button>
        </div>
      </div>
    </div>
  );
};

export default DownloadOptionsModal;

// === File: DraggableElement.css ===


// === File: DraggableElement.jsx ===
import React, { useState, useRef, useEffect } from 'react';
import './DraggableElement.css';

const DraggableElement = ({ 
  id, 
  children, 
  defaultPosition = { x: 0, y: 0 },
  bounds = 'parent'
}) => {
  const [position, setPosition] = useState(defaultPosition);
  const [isDragging, setIsDragging] = useState(false);
  const elementRef = useRef(null);
  const startPos = useRef({ x: 0, y: 0 });

  useEffect(() => {
    setPosition(defaultPosition);
  }, [defaultPosition]);

  const handleMouseDown = (e) => {
    e.preventDefault();
    setIsDragging(true);
    const rect = elementRef.current.getBoundingClientRect();
    startPos.current = {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    };
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
  };

  const handleMouseMove = (e) => {
    if (!isDragging) return;
    
    const container = bounds === 'parent' 
      ? elementRef.current.parentElement 
      : document.querySelector(bounds);
      
    const containerRect = container.getBoundingClientRect();
    const elementRect = elementRef.current.getBoundingClientRect();
    
    let newX = e.clientX - containerRect.left - startPos.current.x;
    let newY = e.clientY - containerRect.top - startPos.current.y;
    
    // Constrain to container bounds
    newX = Math.max(0, Math.min(containerRect.width - elementRect.width, newX));
    newY = Math.max(0, Math.min(containerRect.height - elementRect.height, newY));
    
    setPosition({
      x: (newX / containerRect.width) * 100,
      y: (newY / containerRect.height) * 100
    });
  };

  const handleMouseUp = () => {
    setIsDragging(false);
    document.removeEventListener('mousemove', handleMouseMove);
    document.removeEventListener('mouseup', handleMouseUp);
  };

  const style = {
    position: 'absolute',
    left: `${position.x}%`,
    top: `${position.y}%`,
    transform: 'translate(-50%, -50%)',
    cursor: isDragging ? 'grabbing' : 'grab',
    zIndex: isDragging ? 100 : 10
  };

  return (
    <div
      ref={elementRef}
      className={`draggable-element ${isDragging ? 'dragging' : ''}`}
      style={style}
      onMouseDown={handleMouseDown}
    >
      {children}
    </div>
  );
};

export default DraggableElement;

// === File: LogoManager.jsx ===
import React, { useContext, useState, useRef } from 'react';
import  {CertificateContext}  from '../../../contexts/CertificateContext';
import './Certificate.css';

const LogoManager = () => {
  const { certificate, addLogo, removeLogo } = useContext(CertificateContext);
  const fileInputRef = useRef(null);

  const handleLogoUpload = (e) => {
    const file = e.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (event) => {
        addLogo({
          image: event.target.result,
          position: getDefaultLogoPosition(certificate.logos.length)
        });
      };
      reader.readAsDataURL(file);
    }
  };

  const getDefaultLogoPosition = (index) => {
    const positions = [
      { x: 50, y: 50 },        // Top-left
      { x: '80%', y: 50 },     // Top-right
      { x: 50, y: '80%' },     // Bottom-left
      { x: '80%', y: '80%' }  // Bottom-right (but we'll use this for barcode)
    ];
    return positions[index] || { x: 50, y: 50 };
  };

  return (
    <div className="logo-manager">
      <h3>Add Logos</h3>
      <p>You can add up to 3 logos that will be placed in the corners of the certificate.</p>
      
      <div className="logo-controls">
        <input
          type="file"
          ref={fileInputRef}
          onChange={handleLogoUpload}
          accept="image/*"
          style={{ display: 'none' }}
        />
        <button 
          onClick={() => fileInputRef.current.click()}
          disabled={certificate.logos.length >= 3}
        >
          Add Logo
        </button>
      </div>

      <div className="existing-logos">
        <h3>Current Logos</h3>
        {certificate.logos.length === 0 ? (
          <p>No logos added yet</p>
        ) : (
          <div className="logo-grid">
            {certificate.logos.map((logo, index) => (
              <div key={index} className="logo-item">
                <img src={logo.image} alt={`Logo ${index + 1}`} />
                <button 
                  onClick={() => removeLogo(index)}
                  className="danger"
                >
                  Remove
                </button>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
};

export default LogoManager;

// === File: PreviewModal.css ===


// === File: PreviewModal.jsx ===
import React, { useRef } from 'react';
import { toPng, toJpeg } from 'html-to-image';
import { saveAs } from 'file-saver';
import { jsPDF } from 'jspdf';
import Certificate from './Certificate';
import { FaTimes, FaDownload, FaFilePdf, FaChevronLeft, FaChevronRight } from 'react-icons/fa';
import './PreviewModal.css';

const PreviewModal = ({ 
  onClose, 
  onNavigate, 
  currentIndex = 0, 
  totalCertificates = 1,
  onDownloadAll 
}) => {
  const certificateRef = useRef(null);
  const isBulkMode = totalCertificates > 1;

  const downloadCertificate = async (format) => {
    if (!certificateRef.current) return;

    try {
      let dataUrl;
      const options = {
        quality: 0.95,
        pixelRatio: 3,
        backgroundColor: '#ffffff'
      };

      switch (format) {
        case 'png':
          dataUrl = await toPng(certificateRef.current, options);
          saveAs(dataUrl, `certificate-${Date.now()}.png`);
          break;
        case 'jpeg':
          dataUrl = await toJpeg(certificateRef.current, options);
          saveAs(dataUrl, `certificate-${Date.now()}.jpg`);
          break;
        case 'pdf':
          dataUrl = await toPng(certificateRef.current, options);
          const pdf = new jsPDF('landscape');
          const imgProps = pdf.getImageProperties(dataUrl);
          const pdfWidth = pdf.internal.pageSize.getWidth();
          const pdfHeight = (imgProps.height * pdfWidth) / imgProps.width;
          
          pdf.addImage(dataUrl, 'PNG', 0, 0, pdfWidth, pdfHeight);
          pdf.save(`certificate-${Date.now()}.pdf`);
          break;
        default:
          break;
      }
    } catch (error) {
      console.error('Error generating image:', error);
      alert('Failed to generate certificate image');
    }
  };

  return (
    <div className="preview-modal">
      <div className="preview-content">
        <div className="preview-header">
          <h2>
            {isBulkMode ? `Certificate Preview (${currentIndex + 1} of ${totalCertificates})` : 'Certificate Preview'}
          </h2>
          <button className="close-button" onClick={onClose}>
            <FaTimes />
          </button>
        </div>
        
        {isBulkMode && (
          <div className="bulk-navigation">
            <button 
              className="nav-button"
              onClick={() => onNavigate('prev')}
              disabled={currentIndex === 0}
            >
              <FaChevronLeft /> Previous
            </button>
            <span className="nav-status">
              {currentIndex + 1} / {totalCertificates}
            </span>
            <button 
              className="nav-button"
              onClick={() => onNavigate('next')}
              disabled={currentIndex === totalCertificates - 1}
            >
              Next <FaChevronRight />
            </button>
          </div>
        )}
        
        <div className="certificate-container">
          <div className="certificate-preview" ref={certificateRef}>
            <Certificate />
          </div>
        </div>

        <div className="download-options">
          <button 
            className="download-button"
            onClick={() => downloadCertificate('png')}
          >
            <FaDownload /> Download PNG
          </button>
          <button 
            className="download-button"
            onClick={() => downloadCertificate('jpeg')}
          >
            <FaDownload /> Download JPEG
          </button>
          <button 
            className="download-button pdf"
            onClick={() => downloadCertificate('pdf')}
          >
            <FaFilePdf /> Download PDF
          </button>
          
          {isBulkMode && (
            <button 
              className="download-button primary"
              onClick={onDownloadAll}
            >
              <FaDownload /> Download All as PDF
            </button>
          )}
        </div>
      </div>
    </div>
  );
};

export default PreviewModal;

// === File: SignatureManager.css ===


// === File: SignatureManager.jsx ===
import React, { useContext, useState, useRef } from 'react';
import SignatureCanvas from 'react-signature-canvas';
import { CertificateContext } from '../../../contexts/CertificateContext';
import './SignatureManager.css';

const SignatureManager = () => {
  const { certificate, addSignature, updateSignature, removeSignature } = useContext(CertificateContext);
  const [newSignature, setNewSignature] = useState({
    name: '',
    date: new Date().toISOString().split('T')[0],
    image: ''
  });
  const [isDrawing, setIsDrawing] = useState(false);
  const fileInputRef = useRef(null);
  const sigCanvasRef = useRef(null);
  const [activeTab, setActiveTab] = useState('add');

  const handleInputChange = (e) => {
    const { name, value } = e.target;
    setNewSignature(prev => ({ ...prev, [name]: value }));
  };

  const handleImageUpload = (e) => {
    const file = e.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (event) => {
        setNewSignature(prev => ({
          ...prev,
          image: event.target.result
        }));
      };
      reader.readAsDataURL(file);
    }
  };

  const handleAddSignature = () => {
    if (newSignature.name && newSignature.image) {
      addSignature({
        ...newSignature,
        position: { 
          x: 100 + (certificate.signatures.length * 200), 
          y: 400 
        }
      });
      setNewSignature({
        name: '',
        date: new Date().toISOString().split('T')[0],
        image: ''
      });
      if (sigCanvasRef.current) {
        sigCanvasRef.current.clear();
      }
    }
  };

  const openDrawingPanel = () => {
    setIsDrawing(true);
  };

  const closeDrawingPanel = () => {
    setIsDrawing(false);
  };

  const trimCanvas = (canvas) => {
    const ctx = canvas.getContext('2d');
    const copy = document.createElement('canvas').getContext('2d');
    const pixels = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const l = pixels.data.length;
    let i, bound = {
      top: null,
      left: null,
      right: null,
      bottom: null
    };
    
    for (i = 0; i < l; i += 4) {
      if (pixels.data[i+3] !== 0) {
        const x = (i / 4) % canvas.width;
        const y = Math.floor((i / 4) / canvas.width);
        
        if (bound.top === null) bound.top = y;
        if (bound.left === null || x < bound.left) bound.left = x;
        if (bound.right === null || x > bound.right) bound.right = x;
        if (bound.bottom === null || y > bound.bottom) bound.bottom = y;
      }
    }
    
    const trimHeight = bound.bottom - bound.top;
    const trimWidth = bound.right - bound.left;
    const trimmed = ctx.getImageData(bound.left, bound.top, trimWidth, trimHeight);
    
    const trimmedCanvas = document.createElement('canvas');
    trimmedCanvas.width = trimWidth;
    trimmedCanvas.height = trimHeight;
    trimmedCanvas.getContext('2d').putImageData(trimmed, 0, 0);
    
    return trimmedCanvas;
  };

  const saveDrawing = () => {
    if (sigCanvasRef.current) {
      const canvas = sigCanvasRef.current.getCanvas();
      const trimmedCanvas = trimCanvas(canvas);
      const signatureData = trimmedCanvas.toDataURL('image/png');
      
      setNewSignature(prev => ({
        ...prev,
        image: signatureData
      }));
      setIsDrawing(false);
    }
  };

  const clearDrawing = () => {
    if (sigCanvasRef.current) {
      sigCanvasRef.current.clear();
    }
  };

  return (
    <div className="signature-manager">
      <div className="manager-header">
        <h2>Signature Manager</h2>
        <div className="tabs">
          <button 
            className={`tab-btn ${activeTab === 'add' ? 'active' : ''}`}
            onClick={() => setActiveTab('add')}
          >
            Add Signature
          </button>
          <button 
            className={`tab-btn ${activeTab === 'manage' ? 'active' : ''}`}
            onClick={() => setActiveTab('manage')}
          >
            Manage Signatures
          </button>
        </div>
      </div>

      {isDrawing && (
        <div className="drawing-modal">
          <div className="drawing-panel">
            <div className="drawing-header">
              <h3>Draw Your Signature</h3>
              <button className="close-btn" onClick={closeDrawingPanel}>
                &times;
              </button>
            </div>
            <div className="signature-canvas-container">
              <SignatureCanvas
                ref={sigCanvasRef}
                penColor="black"
                canvasProps={{
                  width: 500,
                  height: 200,
                  className: 'signature-canvas'
                }}
              />
            </div>
            <div className="drawing-controls">
              <button className="clear-btn" onClick={clearDrawing}>
                Clear
              </button>
              <button className="save-btn" onClick={saveDrawing}>
                Save Signature
              </button>
            </div>
          </div>
        </div>
      )}

      {activeTab === 'add' ? (
        <div className="signature-form-container">
          <div className="form-section">
            <div className="form-group">
              <label>Signer's Name</label>
              <input
                type="text"
                name="name"
                value={newSignature.name}
                onChange={handleInputChange}
                placeholder="Enter full name"
              />
            </div>
            <div className="form-group">
              <label>Date</label>
              <input
                type="date"
                name="date"
                value={newSignature.date}
                onChange={handleInputChange}
              />
            </div>
            <div className="form-group">
              <label>Signature Method</label>
              <div className="upload-options">
                <button 
                  className="upload-btn"
                  onClick={() => fileInputRef.current.click()}
                >
                  <i className="icon-upload"></i> Upload Image
                </button>
                <button 
                  className="draw-btn"
                  onClick={openDrawingPanel}
                >
                  <i className="icon-draw"></i> Draw Signature
                </button>
              </div>
              <input
                type="file"
                ref={fileInputRef}
                onChange={handleImageUpload}
                accept="image/*"
                style={{ display: 'none' }}
              />
            </div>
          </div>

          {newSignature.image && (
            <div className="preview-section">
              <h4>Signature Preview</h4>
              <div className="signature-preview">
                <div className="signature-preview-box">
                  <img 
                    src={newSignature.image} 
                    alt="Signature Preview" 
                    onError={(e) => {
                      e.target.src = '';
                      e.target.style.display = 'none';
                    }}
                  />
                </div>
                <div className="signature-details">
                  <p><strong>Name:</strong> {newSignature.name || 'Not specified'}</p>
                  <p><strong>Date:</strong> {newSignature.date}</p>
                </div>
              </div>
              <button 
                className="add-signature-btn"
                onClick={handleAddSignature}
                disabled={!newSignature.name || !newSignature.image}
              >
                Add Signature to Document
              </button>
            </div>
          )}
        </div>
      ) : (
        <div className="existing-signatures">
          {certificate.signatures.length === 0 ? (
            <div className="empty-state">
              <i className="icon-empty"></i>
              <p>No signatures added yet</p>
            </div>
          ) : (
            <div className="signatures-grid">
              {certificate.signatures.map((sig, index) => (
                <div key={index} className="signature-card">
                  <div className="signature-image-container">
                    <img src={sig.image} alt={`Signature ${index + 1}`} />
                  </div>
                  <div className="signature-info">
                    <h4>{sig.name}</h4>
                    <p className="signature-date">{sig.date}</p>
                  </div>
                  <button 
                    className="remove-btn"
                    onClick={() => removeSignature(index)}
                  >
                    <i className="icon-delete"></i> Remove
                  </button>
                </div>
              ))}
            </div>
          )}
        </div>
      )}
    </div>
  );
};

export default SignatureManager;